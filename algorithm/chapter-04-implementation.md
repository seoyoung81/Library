# 🍥 CHAPTER 04  Implementation

## 1. 아이디어를 코드로 바꾸는 구현

## 🐟 피지컬로 승부하기

구현이란 '머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정'이다. 알고리즘을 해결 할 때, 문제의 풀이 방법을 생각하고, 프로그래밍 언어로 구현해냈을 때 정답 처리를 받을 수 있다.

`problem` `thinking` `solution`

피지컬이 좋다 = 프로그래밍 언어의 문법에 능숙하고 코드 작성 속도가 빠른 사람 → 구현 유형의 문제에 유리

❓ 어떤 문제가 구현하기 어려운 문제일까?

* 알고리즘은 간단한데 코드가 매우 긴 문제
* 특정 소수점 자리까지 출력해야 하는 문제
* 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야 하는 문제

→ 사소한 조건 설정이 많은 문제

**구현의 유형**

* 완전 탐색: 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
* 시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행

## 🐟 구현 시 고려해야 할 메모리 제약 사항

파이썬을 사용하는 경우 프로그래머가 직접 자료형을 지정할 필요가 없어 매우 큰 수의 연산을 기본으로 지원한다.&#x20;

### 파이썬에서 리스트 크기

리스트를 이용할 때는 코딩 테스트의 메모리 제한을 고려해야 한다. 대체로 코딩 테스트에서는 128 \~ 512MB로 메모리를 제한한다.

| 데이터의 개수(리스트의 길이) | 메모리 사용량 |
| ---------------- | ------- |
| 1,000            | 약 4KB   |
| 1,000,000        | 약 4MB   |
| 1,000,000,000    | 약 40MB  |

리스트를 여러 개 선언하고, 그 중 크기가 1,000만 이상인 리스트가 있다면 메모리 용량 제한으로 풀 수 없게 된다. 하지만, 매우 드문 경우이다. 수천만 개 이상의 데이터를 입력해야하면 입출력에 너무 많은 시간이 소요되기 때문에 채점 환경에서도 다양한 문제가 발생할 수 있기 때문이다.

## 🐟 채점 환경

보통 코딩테스트 환경에서는

* 시간 제한: 1초
* 메모리 제한: 128KB

파이썬 코드는 1초에 2,000만 번의 연산을 수행한다고 가정하고 문제를 풀면 된다. 시간 제한이 1초, 데이터의 개수가 100만 개인 문제는 시간 복잡도 `O(NlogN)` 이내의 알고리즘을 이용해야 한다. N=1,000,000 일 때, NlogN은 약 20,000,000이다.

시간제한과 데이터의 개수를 먼저 확인한 뒤에 문제를 어느 시간 복잡도의 알고리즘을 작성해야 풀 수 있을 것인지 예측할 수 있어야 한다.

## 🐟 예제

1. 상하좌우

```python
# N 입력받기
n = int(input())
x, y = 1, 1
plans = input().split()

# L, R, U, D에 따른 이동 방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']

# 이동 계획을 하나씩 확인
for plan in plans:
    # 이동 후 좌표 구하기
    for i in range(len(move_types)):
        if plan == move_types[i]:
            nx = x + dx[i]
            ny = y + dy[i]
    # 공간을 벗어나는 경우 무시
    if nx < 1 or ny < 1 or nx > n or ny > n:
        continue
    # 이동 수행
    x, y = nx, ny

print(x, y)
```

이 문제는 개체를 차례대로 이동시킨다는 점에서 시뮬레이션 유형으로 분류된다.&#x20;

2. 시각

```python
# H를 입력받기
h = int(input())

count = 0
for i in range(h + 1):
    for j in range(60):
        for k in range(60):
            # 매 시각 안에 '3'이 포함되어 있다면 카운트 증가
            if '3' in str(i) + str(j) + str(k):
                count += 1

print(count)
```

모든 시각의 경우를 하나씩 세서 풀 수 있다. 모든 경우가 86,400가지이기 때문. 단순히 1씩 증가시키면서 3이 하나라도 포함되어 있는지 확인하면 된다. 완전탐색으로 분류된다. 일반적으로 데이터의 개수가 **100만개 이하**일 때 완전 탐색을 사용하면 된다.

## 2. 실전 문제

## 🐟 실전 문제

