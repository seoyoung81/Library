# Table of contents

* [📓 도서관](README.md)
* [📕 리팩터링 2판](refactoring/README.md)
  * [1️⃣ 1️⃣ CHAPTER 01 리팩터링: 첫 번째 예시](refactoring/chapter01/README.md)
    * [✏️ 1.1 자, 시작해보자!](refactoring/chapter01/1.1.md)
    * [✏️ 1.2 예시 프로그램을 본 소감](refactoring/chapter01/1.2.md)
    * [✏️ 1.3 리팩터링의 첫 단계](refactoring/chapter01/1.3.md)
    * [✏️ 1.4 statement() 함수 쪼개기](refactoring/chapter01/1.4-statement.md)
    * [✏️ 1.5 중간 점검: 난무하는 중첩 함수](refactoring/chapter01/1.5.md)
    * [✏️ 1.6 계산 단계와 포맷팅 단계 분리하기](refactoring/chapter01/1.6.md)
    * [✏️ 1.7 중간 점검: 두 파일(과 두 단계)로 분리됨](refactoring/chapter01/1.7.md)
    * [✏️ 1.8 다형성을 활용해 계산 코드 재구성하기](refactoring/chapter01/1.8.md)
    * [✏️ 1.9 상태 점검: 다형성을 활용하여 데이터 생성하기](refactoring/chapter01/1.9.md)
    * [✏️ 1.10 마치며](refactoring/chapter01/1.10.md)
  * [2️⃣ 2️⃣ CHAPTER 02 리팩터링 원칙](refactoring/chapter02/README.md)
    * [✏️ 2.1 리팩터링 정의](refactoring/chapter02/2.1.md)
    * [✏️ 2.2 두 개의 모자](refactoring/chapter02/2.2.md)
    * [✏️ 2.3 리팩터링하는 이유](refactoring/chapter02/2.3.md)
    * [✏️ 2.4 언제 리팩터링해야 할까?](refactoring/chapter02/2.4.md)
  * [3️⃣ 3️⃣ CHAPTER 03 코드에서 나는 악취](refactoring/chapter03/README.md)
    * [✏️ 3.1 기이한 이름](refactoring/chapter03/3.1.md)
    * [✏️ 3.2 중복 코드](refactoring/chapter03/3.2.md)
    * [✏️ 3.3 긴 함수](refactoring/chapter03/3.3.md)
    * [✏️ 3.4 긴 매개변수 목록](refactoring/chapter03/3.4.md)
    * [✏️ 3.5 전역 데이터](refactoring/chapter03/3.5.md)
    * [✏️ 3.6 가변 데이터](refactoring/chapter03/3.6.md)
    * [✏️ 3.7 뒤엉킨 변경](refactoring/chapter03/3.7.md)
    * [✏️ 3.8 산탄총 수술](refactoring/chapter03/3.8.md)
    * [✏️ 3.9 기능 편애](refactoring/chapter03/3.9.md)
    * [✏️ 3.10 데이터 뭉치](refactoring/chapter03/3.10.md)
    * [✏️ 3.11 기본형 집착](refactoring/chapter03/3.11.md)
    * [✏️ 3.12 반복되는 switch문](refactoring/chapter03/3.12-switch.md)
    * [✏️ 3.13 반복문](refactoring/chapter03/3.13.md)
    * [✏️ 3.14 성의 없는 요소](refactoring/chapter03/3.14.md)
    * [✏️ 3.15 추측성 일반화](refactoring/chapter03/3.15.md)
    * [✏️ 3.16 임시 필드](refactoring/chapter03/3.16.md)
    * [✏️ 3.17 메시지 체인](refactoring/chapter03/3.17.md)
    * [✏️ 3.18 중재자](refactoring/chapter03/3.18.md)
    * [✏️ 3.19 내부자 거래](refactoring/chapter03/3.19.md)
    * [✏️ 3.20 거대한 클래스](refactoring/chapter03/3.20.md)
    * [✏️ 3.21 서로 다른 인터페이스의 대안 클래스들](refactoring/chapter03/3.21.md)
    * [✏️ 3.22 데이터 클래스](refactoring/chapter03/3.22.md)
    * [✏️ 3.23 상속 포기](refactoring/chapter03/3.23.md)
    * [✏️ 3.24 주석](refactoring/chapter03/3.24.md)
  * [4️⃣ 4️⃣ CHAPTER 04 테스트 구축하기](refactoring/chapter04/README.md)
    * [✏️ 4.1 자가 테스트 코드의 가치](refactoring/chapter04/4.1.md)
    * [✏️ 4.2 테스트할 샘플 코드](refactoring/chapter04/4.2.md)
    * [✏️ 4.3 첫 번째 테스트](refactoring/chapter04/4.3.md)
    * [✏️ 4.4 테스트 추가하기](refactoring/chapter04/4.4.md)
    * [✏️ 4.5 픽스처 수정하기](refactoring/chapter04/4.5.md)
    * [✏️ 4.6 경계 조건 검사하기](refactoring/chapter04/4.6.md)
    * [✏️ 4.7 끝나지 않은 여정](refactoring/chapter04/4.7.md)
  * [5️⃣ 5️⃣ CHAPTER 05 리팩터링 카탈로그 보는 법](refactoring/chapter05/README.md)
    * [✏️ 5.1 리팩터링 설명 형식](refactoring/chapter05/5.1.md)
    * [✏️ 5.2 리팩터링 기법 선정 기준](refactoring/chapter05/5.2.md)
  * [6️⃣ 6️⃣ CHAPTER 06 기본적인 리팩터링](refactoring/chapter06/README.md)
    * [✏️ 6.1 함수 추출하기 (Extract Function)](refactoring/chapter06/6.1-extract-function.md)
    * [✏️ 6.2 함수 인라인하기 (Inline Function)](refactoring/chapter06/6.2-inline-function.md)
    * [✏️ 6.3 변수 추출하기 ( Extract Variable)](refactoring/chapter06/6.3-extract-variable.md)
    * [✏️ 6.4 변수 인라인하기 (Inline Variable)](refactoring/chapter06/6.4-inline-variable.md)
    * [✏️ 6.5 함수 선언 바꾸기 (Change Function Declaration)](refactoring/chapter06/6.5-change-function-declaration.md)
    * [✏️ 6.6 변수 캡슐화하기 (Encapsulate Variable)](refactoring/chapter06/6.6-encapsulate-variable.md)
    * [✏️ 6.7 변수 이름 바꾸기 (Rename Variable)](refactoring/chapter06/6.7-rename-variable.md)
    * [✏️ 6.8 매개변수 객체 만들기 (Introduce Parameter Object)](refactoring/chapter06/6.8-introduce-parameter-object.md)
    * [✏️ 6.9 여러 함수를 클래스로 묶기 (Combine Functions into Class)](refactoring/chapter06/6.9-combine-functions-into-class.md)
    * [✏️ 6.10 여러 함수를 변환 함수로 묶기 (Combine Functions into Transform)](refactoring/chapter06/6.10-combine-functions-into-transform.md)
    * [✏️ 6.11 단계 쪼개기 (Split Phase)](refactoring/chapter06/6.11-split-phase.md)
  * [7️⃣ 7️⃣ CHAPTER 07 캡슐화](refactoring/chapter-07/README.md)
    * [✏️ 7.1 레코드 캡슐화하기 (Encapsulate Record)](refactoring/chapter-07/7.1-encapsulate-record.md)
    * [✏️ 7.2 컬렉션 캡슐화하기 (Encapsulate Collection)](refactoring/chapter-07/7.2-encapsulate-collection.md)
    * [✏️ 7.3 기본형을 객체로 바꾸기 (Replace Primitive with Object)](refactoring/chapter-07/7.3-replace-primitive-with-object.md)
    * [✏️ 7.4 임시 변수를 질의 함수로 바꾸기 (Replace Temp with Query)](refactoring/chapter-07/7.4-replace-temp-with-query.md)
    * [✏️ 7.5 클래스 추출하기 (Extract Class)](refactoring/chapter-07/7.5-extract-class.md)
    * [✏️ 7.6 클래스 인라인하기 (Inline Class)](refactoring/chapter-07/7.6-inline-class.md)
    * [✏️ 7.7 위임 숨기기 (Hide Delegate)](refactoring/chapter-07/7.7-hide-delegate.md)
    * [✏️ 7.8 중개자 제거하기 (Reove Middle Man)](refactoring/chapter-07/7.8-reove-middle-man.md)
    * [✏️ 7.9 알고리즘 교체하기 (Subsititue Algorithm)](refactoring/chapter-07/7.9-subsititue-algorithm.md)
  * [8️⃣ 8️⃣ CHAPTER 08 기능 이동](refactoring/chapter-08/README.md)
    * [✏️ 8.1 함수 옮기기 (Move Function)](refactoring/chapter-08/8.1-move-function.md)
    * [✏️ 8.2 필드 옮기기 (Move Field)](refactoring/chapter-08/8.2-move-field.md)
    * [✏️ 8.3 문장을 함수로 옮기기 (Move Statements into Function)](refactoring/chapter-08/8.3-move-statements-into-function.md)
    * [✏️ 8.4 문장을 호출한 곳으로 옮기기 (Move Statements to Callers)](refactoring/chapter-08/8.4-move-statements-to-callers.md)
    * [✏️ 8.5 인라인 코드를 함수 호출로 바꾸기 (Replace Inline Code with Function Call)](refactoring/chapter-08/8.5-replace-inline-code-with-function-call.md)
    * [✏️ 8.6 문장 슬라이드하기 (Slide Statements)](refactoring/chapter-08/8.6-slide-statements.md)
    * [✏️ 8.7 반복문 쪼개기 (Split Loop)](refactoring/chapter-08/8.7-split-loop.md)
    * [✏️ 8.8 반복문을 파이프라인으로 바꾸기 (Replace Loop with Pipeline)](refactoring/chapter-08/8.8-replace-loop-with-pipeline.md)
    * [✏️ 8.9 죽은 코드 제거하기 (Remove Dead Code)](refactoring/chapter-08/8.9-remove-dead-code.md)
  * [9️⃣ 9️⃣ CHAPTER 09 데이터 조직화](refactoring/chapter-09/README.md)
    * [✏️ 9.1 변수 쪼개기 (Split Variable)](refactoring/chapter-09/9.1-split-variable.md)
    * [✏️ 9.2 필드 이름 바꾸기 (Rename Field)](refactoring/chapter-09/9.2-rename-field.md)
    * [✏️ 9.3 파생 변수를 질의 함수로 바꾸기 (Replace Derived Variable with Query)](refactoring/chapter-09/9.3-replace-derived-variable-with-query.md)
    * [✏️ 9.4 참조를 값으로 바꾸기 (Change Reference to Value)](refactoring/chapter-09/9.4-change-reference-to-value.md)
    * [✏️ 9.5 값을 참조로 바꾸기 (Change Value to Reference)](refactoring/chapter-09/9.5-change-value-to-reference.md)
    * [✏️ 9.6 매직 리터럴 바꾸기 (Replace Magic Literal)](refactoring/chapter-09/9.6-replace-magic-literal.md)
  * [🔟 CHAPTER 10 조건부 로직 간소화](refactoring/chapter-10/README.md)
    * [✏️ 10.1 조건문 분해하기 (Decompose Conditional)](refactoring/chapter-10/10.1-decompose-conditional.md)
    * [✏️ 10.2 조건식 통합하기 (Consolidate Conditional Expression)](refactoring/chapter-10/10.2-consolidate-conditional-expression.md)
    * [✏️ 10.3 중첩 조건문을 보호 구문으로 바꾸기 (Replace Nested Conditional with Guard Clauses)](refactoring/chapter-10/10.3-replace-nested-conditional-with-guard-clauses.md)
    * [✏️ 10.4 조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)](refactoring/chapter-10/10.4-replace-conditional-with-polymorphism.md)
    * [✏️ 10.5 특이 케이스 추가하기 (Introduce Special Case)](refactoring/chapter-10/10.5-introduce-special-case.md)
    * [✏️ 10.6 어서션 추가하기 (Introduce Assertion)](refactoring/chapter-10/10.6-introduce-assertion.md)
    * [✏️ 10.7 제어 플래그를 탈출문으로 바꾸기 (Replace Control Flag with Break)](refactoring/chapter-10/10.7-replace-control-flag-with-break.md)
  * [1️⃣ 1️⃣ CHAPTER 11 API 리팩터링](refactoring/chapter-11-api/README.md)
    * [✏️ 11.1 질의 함수와 변경 함수 분리하기](refactoring/chapter-11-api/11.1.md)
    * [✏️ 11.2 함수 매개변수화하기](refactoring/chapter-11-api/11.2.md)
    * [✏️ 11.3 플래그 인수 제거하기](refactoring/chapter-11-api/11.3.md)
    * [✏️ 11.4 객체 통째로 넘기기](refactoring/chapter-11-api/11.4.md)
    * [✏️ 11.5 매개변수를 질의 함수로 바꾸기](refactoring/chapter-11-api/11.5.md)
    * [✏️ 11.6 질의 함수를 매개변수로 바꾸기](refactoring/chapter-11-api/11.6.md)
    * [✏️ 11.7 세터 제거하기](refactoring/chapter-11-api/11.7.md)
    * [✏️ 11.8 생성자를 팩터리 함수로 바꾸기](refactoring/chapter-11-api/11.8.md)
    * [✏️ 11.9 함수를 명령으로 바꾸기](refactoring/chapter-11-api/11.9.md)
    * [✏️ 11.10 명령을 함수로 바꾸기](refactoring/chapter-11-api/11.10.md)
    * [✏️ 11.11 수정된 값 반환하기](refactoring/chapter-11-api/11.11.md)
    * [✏️ 11.12 오류 코드를 예외로 바꾸기](refactoring/chapter-11-api/11.12.md)
    * [✏️ 11.13 예외를 사전 확인으로 바꾸기](refactoring/chapter-11-api/11.13.md)
  * [2️⃣ 2️⃣ CHAPTER 12 상속 다루기](refactoring/chapter-12/README.md)
    * [✏️ 12.1 메서드 올리기](refactoring/chapter-12/12.1.md)
    * [✏️ 12.2 필드 올리기](refactoring/chapter-12/12.2.md)
    * [✏️ 12.3 생성자 본문 올리기](refactoring/chapter-12/12.3.md)
    * [✏️ 12.4 메서드 내리기](refactoring/chapter-12/12.4.md)
    * [✏️ 12.5 필드 내리기](refactoring/chapter-12/12.5.md)
    * [✏️ 12.6 타입 코드를 서브클래스로 바꾸기](refactoring/chapter-12/12.6.md)
    * [✏️ 12.7 서브클래스 제거하기](refactoring/chapter-12/12.7.md)
    * [✏️ 12.8 슈퍼클래스 추출하기](refactoring/chapter-12/12.8.md)
    * [✏️ 12.9 계층 합치기](refactoring/chapter-12/12.9.md)
    * [✏️ 12.10 서브클래스를 위임으로 바꾸기](refactoring/chapter-12/12.10.md)
    * [✏️ 12.11 슈퍼클래스를 위임으로 바꾸기](refactoring/chapter-12/12.11.md)
* [📘 이펙티브 타입스크립트](effective-typescript/README.md)
  * [1️⃣ 1️⃣ 타입스크립트 알아보기](effective-typescript/chapter-1-getting-to-know-typescript/README.md)
    * [📎 아이템 1 타임스크립트와 자바스크립트의 관계 이해하기](effective-typescript/chapter-1-getting-to-know-typescript/item-1-understand-the-relationship-between-typescript-and-javascript.md)
    * [📎 아이템 2 타입스크립트 설정 이해하기](effective-typescript/chapter-1-getting-to-know-typescript/item-2-which-ts.md)
    * [📎 아이템 3 코드 생성과 타입이 관계없음을 이해하기](effective-typescript/chapter-1-getting-to-know-typescript/item-3-independent.md)
    * [📎 아이템 4 구조적 타이핑에 익숙해지기](effective-typescript/chapter-1-getting-to-know-typescript/item-4-structural.md)
    * [📎 아이템 5 any 타입 지양하기](effective-typescript/chapter-1-getting-to-know-typescript/item-5-any.md)
  * [2️⃣ 2️⃣ 타입스크립트의 타입 시스템](effective-typescript/undefined/README.md)
    * [📎 아이템 6 편집기를 사용하여 타입 시스템 탐색하기](effective-typescript/undefined/6.md)
    * [📎 아이템 7 타입이 값들의 집합이라고 생각하기](effective-typescript/chapter-2-typescripts-type-system/item-7-types-as-sets.md)
    * [📎 아이템 8 타입 공간과 값 공간의 심벌 구분하기](effective-typescript/chapter-2-typescripts-type-system/item-8type-value-space.md)
    * [📎 아이템 9 타입 단언보다는 타입 선언을 사용하기](effective-typescript/chapter-2-typescripts-type-system/itme-9-prefer-declarations-to-assertions.md)
    * [📎 아이템 10 객체 래퍼 타입 피하기](effective-typescript/chapter-2-typescripts-type-system/item-10-avoid-object-wrapper-types.md)
    * [📎 아이템 11 잉여 속성 체크의 한계 인지하기](effective-typescript/chapter-2-typescripts-type-system/item-11-excess-property-checking.md)
    * [📎 아이템 12 함수 표현식에 타입 적용하기](effective-typescript/chapter-2-typescripts-type-system/item-12-type-entire-functions.md)
    * [📎 아이템 13 타입과 인터페이스의 차이점 알기](effective-typescript/chapter-2-typescripts-type-system/item-13-type-vs-interface.md)
    * [📎 아이템 14 타입 연산과 제너릭 사용으로 반복 줄이기](effective-typescript/chapter-2-typescripts-type-system/item-14-map-between-types.md)
    * [📎 아이템 15 동적 데이터에 인덱스 시그니처 사용하기](effective-typescript/chapter-2-typescripts-type-system/item-15-index-for-dynamic.md)
    * [📎 아이템 16 number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기](effective-typescript/chapter-2-typescripts-type-system/item-16-array-tuple-arraylike.md)
    * [📎 아이템 17 변경 관련된 오류 방지를 위해 readonly 사용하기](effective-typescript/chapter-2-typescripts-type-system/item-17-readonly.md)
    * [📎 아이템 18 매핑된 타입을 사용하여 값을 동기화하기](effective-typescript/chapter-2-typescripts-type-system/item-18-mapping-type.md)
  * [3️⃣ 3️⃣ 타입 추론](effective-typescript/chapter-3-type-inference/README.md)
    * [📎 아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기](effective-typescript/chapter-3-type-inference/item-19-avoid-inferable.md)
    * [📎 아이템 20 다른 타입에는 다른 변수 사용하기](effective-typescript/chapter-3-type-inference/item-20-one-var-one-type.md)
    * [📎 아이템 21 타입 넓히기](effective-typescript/chapter-3-type-inference/item-21-widening.md)
    * [📎 아이템 22 타입 좁히기](effective-typescript/chapter-3-type-inference/item-22-narrowing.md)
    * [📎 아이템 23 한꺼번에 객체 생성하기](effective-typescript/chapter-3-type-inference/item-23-all-at-once.md)
    * [📎 아이템 24 일관성 있는 별칭 사용하기](effective-typescript/chapter-3-type-inference/item-24-avoid-aliasing.md)
    * [📎 아이템 25 비동기 코드에는 콜백 대신 async 함수 사용하기](effective-typescript/chapter-3-type-inference/item-25-use-async-await.md)
    * [📎 아이템 26 타입 추론에 문맥이 어떻게 사용되는지 이해하기](effective-typescript/chapter-3-type-inference/item-26-context-inference.md)
    * [📎 아이템 27 함수형 기법과 라이브러리로 타입 흐름 유지하기](effective-typescript/chapter-3-type-inference/item-27-functional-libraries.md)
  * [4️⃣ 4️⃣ 타입 설계](effective-typescript/chapter-4-type-design/README.md)
    * [📎 아이템 28 유효한 상태만 표현하는 타입을 지향하기](effective-typescript/chapter-4-type-design/item-28-valid-states.md)
    * [📎 아이템 29 사용할 때는 너그럽게, 생성할 때는 엄격하게](effective-typescript/chapter-4-type-design/item-29-loose-accept-strict-produce.md)
    * [📎 아이템 30 문서에 타입 정보를 쓰지 않기](effective-typescript/chapter-4-type-design/item-30-jsdoc-repeat.md)
    * [📎 아이템 31 타입 주변에 null 값 배치하기](effective-typescript/chapter-4-type-design/item-31-null-values-to-perimeter.md)
    * [📎 아이템 32 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기](effective-typescript/chapter-4-type-design/item-32-union-of-interfaces.md)
    * [📎 아이템 33 string 타입보다 더 구체적인 타입 사용하기](effective-typescript/chapter-4-type-design/item-33-avoid-strings.md)
    * [📎 아이템 34 부정확한 타입보다는 미완성 타입을 사용하기](effective-typescript/chapter-4-type-design/34.md)
    * [📎 아이템 35 데이터가 아닌, API와 명세를 보고 타입 만들기](effective-typescript/chapter-4-type-design/35-api.md)
    * [📎 아이템 36 해당 분야의 용어로 타입 이름 짓기](effective-typescript/chapter-4-type-design/item-36-language-of-domain.md)
    * [📎 아이템 37 공식 명칭에는 상표를 붙이기](effective-typescript/chapter-4-type-design/item-37.md)
  * [5️⃣ 5️⃣ any 다루기](effective-typescript/chapter-5-any/README.md)
    * [📎 아이템 38 any 타입은 가능한 한 좁은 범위에서만 사용하기](effective-typescript/chapter-5-any/item-38-narrowest-any.md)
    * [📎 아이템 39 any를 구체적으로 변형해서 사용하기](effective-typescript/chapter-5-any/item-39-specific-any.md)
    * [📎 아이템 40 함수 안으로 타입 단언문 감추기](effective-typescript/chapter-5-any/item-40-hide.md)
    * [📎 아이템 41 any의 진화를 이해하기](effective-typescript/chapter-5-any/item-41-understand-any-evolution.md)
    * [📎 아이템 42 모르는 타입의 값에는 any 대신 unkown을 사용하기](effective-typescript/chapter-5-any/item-42-never-unknown.md)
    * [📎 아이템 43 몽키 패치보다는 안전한 타입을 사용하기](effective-typescript/chapter-5-any/item-43-type-safe-monkey.md)
    * [📎 아이템 44 타입 커버리지를 추적하여 타입 안전성 유지하기](effective-typescript/chapter-5-any/44.md)
  * [6️⃣ 6️⃣ 타입 선언과 @types](effective-typescript/chpater-06-type-declarations-and-types/README.md)
    * [📎 아이템 45 devDependencies에 typescript와 @types 추가하기](effective-typescript/chpater-06-type-declarations-and-types/item-45-dev-dependencies.md)
    * [📎 아이템 46 타입 선언과 관련된 세 가지 버전 이해하기](effective-typescript/chpater-06-type-declarations-and-types/item-46-three-versions.md)
    * [📎 아이템 47 공개 API에 등장하는 모든 타입을 익스포트하기](effective-typescript/chpater-06-type-declarations-and-types/item-37-export-your-types.md)
    * [📎 아이템 48 API 주석에 TSDoc 사용하기](effective-typescript/chpater-06-type-declarations-and-types/item-48-use-tsdoc.md)
    * [📎 아이템 49 콜백에서 this에 대한 타입 제공하기](effective-typescript/chpater-06-type-declarations-and-types/item-49-this-in-callbacks.md)
    * [📎 아이템 50 오버로딩 타입보다는 조건부 타입을 사용하기](effective-typescript/chpater-06-type-declarations-and-types/item-50-overloading.md)
    * [📎 아이템 51 의존성 분리를 위해 미러 타입 사용하기](effective-typescript/chpater-06-type-declarations-and-types/item-51-mirror-types-for-deps.md)
    * [📎 아이템 52 테스팅 타입의 함정에 주의하기](effective-typescript/chpater-06-type-declarations-and-types/item-52-testing-type.md)
  * [7️⃣ 7️⃣ 코드를 작성하고 실행하기](effective-typescript/chpater-07-writing-and-running-your-code/README.md)
    * [📎 아이템 53 타입스크립트 기능보다는 ECMAScript 기능을 사용하기](effective-typescript/chpater-07-writing-and-running-your-code/item-53-avoid-non-ecma.md)
    * [📎 아이템 54 객체를 순회하는 노하우](effective-typescript/chpater-07-writing-and-running-your-code/54.md)
    * [📎 아이템 55 DOM 계층 구조 이해하기](effective-typescript/chpater-07-writing-and-running-your-code/55-dom.md)
    * [📎 아이템 56 정보를 감추는 목적으로 private 사용하지 않기](effective-typescript/chpater-07-writing-and-running-your-code/56-private.md)
    * [📎 아이템 57 소스맵을 사용하여 타입스크립트 디버깅하기](effective-typescript/chpater-07-writing-and-running-your-code/item-57-source-map.md)
  * [8️⃣ 8️⃣ 타입스크립트로 마이그레이션하기](effective-typescript/chapter-08-migration/README.md)
    * [📎 아이템 58 모던 자바스크립트로 작성하기](effective-typescript/chapter-08-migration/item-58-write-modern-js.md)
    * [📎 아이템 59 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해보기](effective-typescript/chapter-08-migration/item-59-jsdoc-tscheck.md)
    * [📎 아이템 60 allowJs로 타입스크립트와 자바스크립트 같이 사용하기](effective-typescript/chapter-08-migration/item-60-allowjs.md)
    * [📎 아이템 61 의존성 관계에 따라 모듈 단위로 전환하기](effective-typescript/chapter-08-migration/item-61-convert-up.md)
    * [📎 아이템 62 마이그레이션의 완성을 위해 noImplicitAny 설정하기](effective-typescript/chapter-08-migration/item-62-noimplicitany.md)
* [📔 You Don't Know JS Yet](you-dont-know-js-yet/README.md)
  * [1️⃣ 1️⃣ CHAPTER 1 자바스크립트](you-dont-know-js-yet/chapter-1/README.md)
    * [💡 1.1 책에 대하여](you-dont-know-js-yet/chapter-1/1.1.md)
    * [💡 1.2 자바스크립트 이름의 유래](you-dont-know-js-yet/chapter-1/1.2.md)
    * [💡 1.3 명세서](you-dont-know-js-yet/chapter-1/1.3.md)
    * [💡 1.4 JS의 다양한 얼굴](you-dont-know-js-yet/chapter-1/1.4-js-paradigm.md)
    * [💡 1.5 하위 호환성과 상위 호환성](you-dont-know-js-yet/chapter-1/1.5.md)
    * [💡 1.6 인터프리터 이해하기](you-dont-know-js-yet/chapter-1/1.6.md)
    * [💡 1.7 엄격모드](you-dont-know-js-yet/chapter-1/1.7.md)
    * [💡 1.8 정리](you-dont-know-js-yet/chapter-1/1.8.md)
* [📗 이것이 취업을 위한 코딩 테스트다](algorithm/README.md)
  * [CHAPTER 03 Greedy](algorithm/chapter-03-greedy.md)
