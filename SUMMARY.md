# Table of contents

* [📓 도서관](README.md)
* [📕 리팩터링 2판](refactoring/README.md)
  * [1️⃣ CHAPTER 01 리팩터링: 첫 번째 예시](refactoring/chapter01/README.md)
    * [✏️ 1.1 자, 시작해보자!](refactoring/chapter01/1.1.md)
    * [✏️ 1.2 예시 프로그램을 본 소감](refactoring/chapter01/1.2.md)
    * [✏️ 1.3 리팩터링의 첫 단계](refactoring/chapter01/1.3.md)
    * [✏️ 1.4 statement() 함수 쪼개기](refactoring/chapter01/1.4-statement.md)
    * [✏️ 1.5 중간 점검: 난무하는 중첩 함수](refactoring/chapter01/1.5.md)
    * [✏️ 1.6 계산 단계와 포맷팅 단계 분리하기](refactoring/chapter01/1.6.md)
    * [✏️ 1.7 중간 점검: 두 파일(과 두 단계)로 분리됨](refactoring/chapter01/1.7.md)
    * [✏️ 1.8 다형성을 활용해 계산 코드 재구성하기](refactoring/chapter01/1.8.md)
    * [✏️ 1.9 상태 점검: 다형성을 활용하여 데이터 생성하기](refactoring/chapter01/1.9.md)
    * [✏️ 1.10 마치며](refactoring/chapter01/1.10.md)
  * [2️⃣ CHAPTER 02 리팩터링 원칙](refactoring/chapter02/README.md)
    * [✏️ 2.1 리팩터링 정의](refactoring/chapter02/2.1.md)
    * [✏️ 2.2 두 개의 모자](refactoring/chapter02/2.2.md)
    * [✏️ 2.3 리팩터링하는 이유](refactoring/chapter02/2.3.md)
    * [✏️ 2.4 언제 리팩터링해야 할까?](refactoring/chapter02/2.4.md)
  * [3️⃣ CHAPTER 03 코드에서 나는 악취](refactoring/chapter03/README.md)
    * [✏️ 3.1 기이한 이름](refactoring/chapter03/3.1.md)
    * [✏️ 3.2 중복 코드](refactoring/chapter03/3.2.md)
    * [✏️ 3.3 긴 함수](refactoring/chapter03/3.3.md)
    * [✏️ 3.4 긴 매개변수 목록](refactoring/chapter03/3.4.md)
    * [✏️ 3.5 전역 데이터](refactoring/chapter03/3.5.md)
    * [✏️ 3.6 가변 데이터](refactoring/chapter03/3.6.md)
    * [✏️ 3.7 뒤엉킨 변경](refactoring/chapter03/3.7.md)
    * [✏️ 3.8 산탄총 수술](refactoring/chapter03/3.8.md)
    * [✏️ 3.9 기능 편애](refactoring/chapter03/3.9.md)
    * [✏️ 3.10 데이터 뭉치](refactoring/chapter03/3.10.md)
    * [✏️ 3.11 기본형 집착](refactoring/chapter03/3.11.md)
    * [✏️ 3.12 반복되는 switch문](refactoring/chapter03/3.12-switch.md)
    * [✏️ 3.13 반복문](refactoring/chapter03/3.13.md)
    * [✏️ 3.14 성의 없는 요소](refactoring/chapter03/3.14.md)
    * [✏️ 3.15 추측성 일반화](refactoring/chapter03/3.15.md)
    * [✏️ 3.16 임시 필드](refactoring/chapter03/3.16.md)
    * [✏️ 3.17 메시지 체인](refactoring/chapter03/3.17.md)
    * [✏️ 3.18 중재자](refactoring/chapter03/3.18.md)
    * [✏️ 3.19 내부자 거래](refactoring/chapter03/3.19.md)
    * [✏️ 3.20 거대한 클래스](refactoring/chapter03/3.20.md)
    * [✏️ 3.21 서로 다른 인터페이스의 대안 클래스들](refactoring/chapter03/3.21.md)
    * [✏️ 3.22 데이터 클래스](refactoring/chapter03/3.22.md)
    * [✏️ 3.23 상속 포기](refactoring/chapter03/3.23.md)
    * [✏️ 3.24 주석](refactoring/chapter03/3.24.md)
  * [4️⃣ CHAPTER 04 테스트 구축하기](refactoring/chapter04/README.md)
    * [✏️ 4.1 자가 테스트 코드의 가치](refactoring/chapter04/4.1.md)
    * [✏️ 4.2 테스트할 샘플 코드](refactoring/chapter04/4.2.md)
    * [✏️ 4.3 첫 번째 테스트](refactoring/chapter04/4.3.md)
    * [✏️ 4.4 테스트 추가하기](refactoring/chapter04/4.4.md)
    * [✏️ 4.5 픽스처 수정하기](refactoring/chapter04/4.5.md)
    * [✏️ 4.6 경계 조건 검사하기](refactoring/chapter04/4.6.md)
    * [✏️ 4.7 끝나지 않은 여정](refactoring/chapter04/4.7.md)
  * [5️⃣ CHAPTER 05 리팩터링 카탈로그 보는 법](refactoring/chapter05/README.md)
    * [✏️ 5.1 리팩터링 설명 형식](refactoring/chapter05/5.1.md)
    * [✏️ 5.2 리팩터링 기법 선정 기준](refactoring/chapter05/5.2.md)
  * [6️⃣ 기본적인 리팩터링](refactoring/undefined/README.md)
    * [✏️ 6.1 함수 추출하기 (Extract Function)](refactoring/undefined/6.1-extract-function.md)
    * [✏️ 6.2 함수 인라인하기 (Inline Function)](refactoring/undefined/6.2-inline-function.md)
